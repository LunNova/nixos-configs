{
  description = "lun's system config";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable-small";
    nixpkgs-mesa-pr.url = "github:NixOS/nixpkgs/837bdeb0251fe30e85ebbd66db20ffb6c66083e3";
    nixpkgs-stable.url = "github:NixOS/nixpkgs/release-22.05";
    home-manager.url = "github:nix-community/home-manager/master";
    home-manager.inputs.nixpkgs.follows = "nixpkgs";
    pre-commit-hooks.url = "github:cachix/pre-commit-hooks.nix";
    pre-commit-hooks.inputs.flake-utils.follows = "flake-utils";
    pre-commit-hooks.inputs.nixpkgs.follows = "nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
    nix-gaming.url = "github:fufexan/nix-gaming";
    nix-gaming.inputs.nixpkgs.follows = "nixpkgs";
    nixos-hardware.url = "github:NixOS/nixos-hardware/master";
    erosanix.url = "github:emmanuelrosa/erosanix";
    erosanix.inputs.nixpkgs.follows = "nixpkgs";
    oxalica-nil.url = "github:oxalica/nil";
    oxalica-nil.inputs.nixpkgs.follows = "nixpkgs";
    oxalica-nil.inputs.flake-utils.follows = "flake-utils";
    thoth-reminder-bot.url = "github:mmk150/reminder_bot";
    thoth-reminder-bot.inputs.nixpkgs.follows = "nixpkgs";
    thoth-reminder-bot.inputs.flake-utils.follows = "flake-utils";
    nixpkgs-review-checks.url = "github:SuperSandro2000/nixpkgs-review-checks";
    nixpkgs-review-checks.inputs.nixpkgs.follows = "nixpkgs";
    nixpkgs-review-checks.inputs.flake-utils.follows = "flake-utils";
    deploy-rs.url = "github:serokell/deploy-rs";
    deploy-rs.inputs.nixpkgs.follows = "nixpkgs";

    linux-freedesktop-drm-misc-fixes = {
      url = "github:freedesktop/drm-misc/drm-misc-fixes";
      flake = false;
    };
    linux-freedesktop-drm-tip = {
      # hash as master hangs amdgpu
      url = "github:freedesktop/drm-tip/601ffaf144034fa3b695c085e38692e1beedcbcf";
      flake = false;
    };
    linux-rc = {
      # hash as master hangs amdgpu
      url = "github:torvalds/linux/v6.1";
      flake = false;
    };

    minimal-shell.url = "github:LunNova/nix-minimal-shell";

    # Powercord. pcp- and pct- prefix have meaning, cause inclusion as powercord plugin/theme
    replugged-nix-flake = {
      url = "github:LunNova/replugged-nix-flake";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    # TODO: check for web access loading scripts and patch out
    # pcp-tweaks = { url = "github:NurMarvin/discord-tweaks"; flake = false; };
    # pcp-theme-toggler = { url = "github:redstonekasi/theme-toggler"; flake = false; };
    #Doesn't work on electron 15
    # pcp-better-status-indicators = { url = "github:GriefMoDz/better-status-indicators"; flake = false; };
    pcp-webhook-tag = { url = "github:BenSegal855/webhook-tag"; flake = false; };
    pcp-always-push = { url = "github:Karamu98/AlwaysPushNotifications"; flake = false; };
    # TODO: locked version of this which doesn't hit web
    pct-clearvision = { url = "github:ClearVision/ClearVision-v6"; flake = false; };
    # pcp-hidden = { url = "github:discord-modifications/show-hidden-channels"; flake = false; };
    # TODO: background overrides here instead of manually configured?
  };

  outputs =
    { self
    , nixpkgs
    , home-manager
    , pre-commit-hooks
    , nix-gaming
    , ...
    }@args:
    # SCHEMA:
    # lib                       = nix library functions, work on any system
    # nixosConfigurations       = attrset with nixosConfigurations by hostname, each host is for one specific system
    # perSystem                 = function which takes system as input
    #                             (system: { packages, legacyPackages, homeConfigurations, checks, slowChecks })
    #                             and generates system specific outputs for that system
    # packages.system           = attrset with packages marked as able to eval/build, generated by perSystem
    # legacyPackages.system     = attrset with packages including unsupported/marked broken, generated by perSystem
    # homeConfigurations.system = attrset with homeConfigurations by username, generated by perSystem
    # checks.system             = attrset with checks, generated by perSystem
    # slowChecks.system         = attrset with checks that are too slow for nix flake check but are used in CI, generated by perSystem
    let
      fullSelf =
        let
          self = with self.priv; {
            # exposing things that I would've put in a let binding unexposed originally
            # this lets them be evaled with nix eval .#priv for debugging
            priv = {
              bootstrapLib = args.nixpkgs.lib;
              enableKwinFt = false;
              pkgsPatches = [
                # add .patch to a github PR URL to get a patch quickly
                ./nixpkgs-patches/lutris-xdg-data-dirs.patch
                ./nixpkgs-patches/201119-tailscale-routing.patch
              ];
              defaultPkgsConfig = {
                config.allowUnfree = true;
                overlays = [
                  # (final: prev: {
                  #   some-package = ...
                  # })
                  self.overlay
                ];
              };
              localPackagesProto = import ./packages;
              localPackagesForPkgs = pkgs: localPackagesProto {
                inherit pkgs;
                flake-args = args;
              };
              readModules = path: builtins.map (x: path + "/${x}") (builtins.filter (str: (builtins.match "^[^.]*(\.nix)?$" str) != null) (builtins.attrNames (builtins.readDir path)));
              readExportedModules = path: bootstrapLib.mapAttrs'
                (key: _value:
                  bootstrapLib.nameValuePair
                    (bootstrapLib.removeSuffix ".nix" key)
                    ({ pkgs, ... }@args: import (path + "/${key}") (args // {
                      pkgs = args.pkgs // { lun = args.pkgs.lun or (localPackagesForPkgs args.pkgs); };
                    })))
                (builtins.readDir path);
            };
            inputs = args;
            lib = import ./lib { inherit bootstrapLib; };
            overlay = final: prev:
              let localPackages = localPackagesForPkgs final;
              in
              {
                lun = localPackages;
                powercord-plugins = self.lib.filterPrefix "pcp-" args;
                powercord-themes = self.lib.filterPrefix "pct-" args;
                inherit (localPackages) kwinft;
                nix-gaming = args.nix-gaming.packages.${final.system};
                # gst-plugins-bad pulls in opencv which we don't want
                # TODO: upstream option for this
                # gst_all_1 = (prev.gst_all_1 // {
                #   gst-plugins-bad = (prev.gst_all_1.gst-plugins-bad.override {
                #     opencv4 = prev.emptyDirectory;
                #   }).overrideAttrs
                #     (prev: {
                #       mesonFlags = prev.mesonFlags ++ [ "-Dopencv=disabled" ];
                #     });
                # });
                # FIXME: kwin tearing patch results in no display
                # plasma5Packages = prev.plasma5Packages.overrideScope' (_self2: super2: {
                #   plasma5 = super2.plasma5.overrideScope' (_self1: super1: {
                #     inherit (prev.plasma5Packages.plasma5) plasma-workspace;
                #     kwin = super1.kwin.overrideAttrs (old: {
                #       # src = pkgs.fetchFromGitLab {
                #       #   domain = "invent.kde.org";
                #       #   owner = "plasma";
                #       #   repo = "kwin";
                #       #   rev = "f7648611573a893dc0f4a8d3ad7ed80e1ff82749";
                #       #   sha256 = "sha256-OkLi3nU1iBuELffC4I97TvsFkws3ihTHNeo2gVbQfN8=";
                #       # };
                #       patches = (old.patches or []) ++ [
                #         ./packages/kwin/927-tearing.patch
                #        ];
                #     });
                #   });
                # });
              } // (self.lib.setIf enableKwinFt {
                plasma5Packages = prev.plasma5Packages.overrideScope' (_self2: super2: {
                  plasma5 = super2.plasma5.overrideScope' (_self1: _super1: {
                    inherit (localPackages.kwinft) kwin;
                    inherit (prev.plasma5Packages.plasma5) plasma-workspace;
                  });
                });
                # TODO: can we get disman and kdisplay included just with this toggle
              });

            nixosModules = readExportedModules ./modules/exported;

            nixosConfigurations = {
              router-nixos = (self.perSystem "x86_64-linux").makeHost ./hosts/router;
              lun-kosame-nixos = (self.perSystem "x86_64-linux").makeHost ./hosts/kosame;
              lun-hisame-nixos = (self.perSystem "x86_64-linux").makeHost ./hosts/hisame;
              mmk-raikiri-nixos = (self.perSystem "x86_64-linux").makeHost ./hosts/raikiri;
            };

            assets = import ./assets;

            deploy.nodes.router = {
              hostname = "10.5.5.1"; # "router-nixos";
              profiles.system = {
                sshUser = "lun";
                user = "root";
                path = args.deploy-rs.lib.x86_64-linux.activate.nixos self.nixosConfigurations.router-nixos;
              };
            };

            perSystem = system:
              let
                lib = perSystemSelf.nixpkgsLib;
                perSystemSelf = {
                  # hack: only patch for x86_64 so nix flake check doesn't fall over for other platforms
                  # eventually will get rid of this IFD
                  # once there's patches support for flake inputs
                  # https://github.com/NixOS/nix/pull/6530
                  pkgs = self.lib.mkPkgs args.nixpkgs system (if system == "x86_64-linux" then pkgsPatches else [ ]) (defaultPkgsConfig // { inherit system; });
                  pkgs-stable = self.lib.mkPkgs args.nixpkgs-stable system [ ] (defaultPkgsConfig // { inherit system; });
                  nixpkgsLib = nixpkgs.lib.extend (final: _prev: {
                    nixosSystem = args:
                      import "${nixpkgs}/nixos/lib/eval-config.nix" (args // {
                        modules = args.modules ++ [{
                          system.nixos.versionSuffix = "";
                          system.nixos.revision = "";
                        }];
                      });

                  });
                  makeHost = path: lib.nixosSystem {
                    inherit (perSystemSelf.pkgs) system;

                    specialArgs =
                      {
                        inherit (perSystemSelf) pkgs-stable;
                        flake-args = args;
                        nixos-hardware-modules-path = "${args.nixos-hardware}";
                      };

                    modules = [
                      { nixpkgs.pkgs = perSystemSelf.pkgs; }
                      home-manager.nixosModules.home-manager
                      nix-gaming.nixosModules.pipewireLowLatency
                      path
                      ./users
                      ({ config, ... }:
                        {
                          config = {
                            home-manager.extraSpecialArgs = {
                              inherit (perSystemSelf) pkgs-stable;
                              flake-args = args;
                              lun-profiles = config.lun.profiles;
                            };
                            home-manager.useGlobalPkgs = true;
                            home-manager.useUserPackages = true;
                          };
                        })
                    ]
                    ++ (builtins.attrValues self.nixosModules)
                    ++ (readModules ./modules);
                  };
                  legacyPackages = localPackagesForPkgs perSystemSelf.pkgs;
                  packages = lib.filterAttrs (_k: pkg: lib.isDerivation pkg && !((pkg.meta or { }).broken or false) && (!(pkg ? meta && pkg.meta ? platforms) || builtins.elem system pkg.meta.platforms)) perSystemSelf.legacyPackages;
                  devShell = args.minimal-shell.lib.minimal-shell {
                    inherit system;
                    inherit (perSystemSelf) pkgs;
                    passthru = {
                      nativeBuildInputs = [ perSystemSelf.pkgs.nixpkgs-fmt ];
                    };
                    # TODO handle buildInputs in minimal-shell
                    shellHooks = perSystemSelf.checks.pre-commit-check.shellHook;
                  };

                  homeConfigurations =
                    let
                      makeUser = username:
                        import "${home-manager}/modules" {
                          inherit (perSystemSelf) pkgs;
                          check = true;
                          extraSpecialArgs = {
                            inherit (perSystemSelf) pkgs-stable;
                            nixosConfig = null;
                            lun-profiles = {
                              graphical = true;
                            };
                            flake-args = args;
                          };
                          configuration = {
                            _module.args.pkgs = lib.mkForce perSystemSelf.pkgs;
                            _module.args.pkgs_i686 = lib.mkForce { };
                            imports = [ "${./users}/${username}" ];
                            home.homeDirectory = "/home/${username}";
                            home.username = "${username}";
                          };
                        };
                    in
                    {
                      lun = makeUser "lun";
                      mmk = makeUser "mmk";
                    };
                  slowChecks = rec {
                    all-packages = perSystemSelf.pkgs.symlinkJoin {
                      name = "lun packages.${system}";
                      paths = lib.attrValues perSystemSelf.packages;
                    };
                    all-systems = perSystemSelf.pkgs.symlinkJoin {
                      name = "lun nixosConfigurations for system ${system}";
                      paths = lib.filter (x: x.system == system) (map (cfg: self.nixosConfigurations.${cfg}.config.system.build.toplevel) (builtins.attrNames self.nixosConfigurations));
                    };
                    all-users = perSystemSelf.pkgs.symlinkJoin {
                      name = "lun homeConfigurations for system ${system}";
                      paths = map (x: x.activationPackage) (lib.attrValues perSystemSelf.homeConfigurations);
                    };
                    all = perSystemSelf.pkgs.symlinkJoin {
                      name = "lun all";
                      paths = [ all-packages all-systems all-users ];
                    };
                  };
                  checks = {
                    pre-commit-check = pre-commit-hooks.lib.${system}.run {
                      src = ./.;
                      hooks = {
                        statix.enable = true;
                        nixpkgs-fmt.enable = true;
                        shellcheck = {
                          enable = true;
                          files = "\\.sh$";
                          types_or = lib.mkForce [ ];
                        };
                        shfmt = {
                          enable = true;
                          files = "\\.sh$";
                        };
                      };
                    };
                  } // args.deploy-rs.lib.${system}.deployChecks self.deploy;
                };
              in
              perSystemSelf;
          };
        in
        self.lib.recursiveMerge [ self (args.flake-utils.lib.eachDefaultSystem self.perSystem) ];
    in
    fullSelf;
}
